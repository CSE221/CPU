\documentclass[10pt]{article}
\usepackage{setspace}
\usepackage{amsthm}
\usepackage{colortbl}
\usepackage{color}
\usepackage{subcaption}
\usepackage{fixltx2e}
\usepackage{booktabs}
\usepackage{times}
\usepackage{arydshln}
\usepackage{tabularx}
\usepackage{mdframed}
\usepackage{amssymb}
\input{preamble}

\newcommand{\xun}[1]{\reminder{green}{xun}{#1}}
\newcommand{\chunbin}[1]{\reminder{red}{chunbin}{#1}}
\newcommand{\jiapeng}[1]{\reminder{blue}{jiapeng}{#1}}





\begin{document}
\title{CSE221-Wi15: Ubuntu 14.04.1 Performance Measurements}
\author{Xun Jiao A******* , Jiapeng Zhang A********, Chunbin Lin A53042883}
\maketitle
\begin{abstract}
In building an operating system, it is important to be able to determine the performance characteristics of underlying hardware components (CPU, RAM, disk, network, etc.), and to understand how their performance influences or constrains operating system services. Likewise, in building an application, one should understand the performance of the underlying hardware and operating system, and how they relate to the user's subjective sense of that application's ``responsiveness''. While some of the relevant quantities can be found in specs and documentation, many must be determined experimentally. While some values may be used to predict others, the relations between lower-level and higher-level performance are often subtle and non-obvious.

In this project, we will create, justify, and apply a set of experiments to a system to characterize and understand its performance. In addition, we also explore the relations between some of these quantities. One of the goal of this project it that we will study how to use benchmarks to usefully characterize a complex system, and also we will also gain an intuitive feel for the relative speeds of different basic operations, which is invaluable in identifying performance bottlenecks.
%% \vspace{+0.1in}
\end{abstract}

\section{Introduction}
\label{sec:int}
In this project, we will learn how to measure the performance of an operating system using various user- and system-level operations. Based on prior knowledge of hardware performance as well as measured software behavior, we will approximately estimate the overhead at the operating system level of the whole system hardware/software stack. We select a well-known multi-user time-sharing operating system, Ubuntu 14.04.1 LTS (desktop) \footnote{http://www.ubuntu.com/download/desktop}, as our experiment platform. This is a long time supported Linux distribution with stable performance and reliable system functions. Our hardware platform is a $Lenovo Y400$  workstation equipped with an $Intel$  $4 cores$ processor. The experimental results indicate that our system configuration is trustable, it also helps us understand the underlying mechanisms of the system as a good reference, which interacts with both software from upper-layer and hardware from lower-layer.
In this project, our major achievement is on the design of experiments (DOE), prediction of performance and analysis on the performance gap between predictive and measured ones. We implement our ideas of DOE by $C$ programming to verify how the system and user operations will impact the performance. We use $gcc$ as the major compiler for our experiments, with all optimization options turned off in the Makefiles. Optimization options intentionally changes code sections to pursue performance gain, which unintentionally disables our desired operations and effect of measurement. As a result, most of our programs are expected to be directly compiled (or, ``interpreted'') in a compiler's perspective.
This project constructs an impressive structure of computing system, in which the operating system plays an role of administrator and coordinator between the application requests and device supports. We are able to effectively analyze an operating system, identify major features of design, advantages and disadvantages, and most importantly, how this middle layer of coordinator impacts the overall performance of the whole stack and how we could possibly improve it based on our accumulated experiences on it.

\subsection{Tasks Allocation}
\chunbin{Xun will conduct the  CPU experiments, and  Chunbin will conduct the Memory experiments. Jiapeng will conduct the File system experiments. We will work together to finish the Network experiments.}

We will spend about 90 hours on this project in total (10 hours per week, and we will use 9 weeks) including the time on reading related papers.

\section{Machine Description}
\label{sec:pc}
All the experiments that we conducted are on the machine and the system, which is characterized in Table \ref{tab:pc}.
This is a $Lenovo Y400$ desktop 64bit machine manufactured. It has a wired network connection to the local area network gated by $137.110.161.79$ located in the office $3232$, CSE department. The operating system running on it is an Ubuntu 14.04.1 LTS desktop.
Notice that we include some basic hardware performance numbers of machine components which are obtained from the manufacturer's datasheets, e.g., I/O bus operating speed, etc. These numbers facilitate our raw performance estimation of running the applications on the stacked layers. These numbers will be frequently referred to in our overhead measurement during the following sections.

%\begin{comment}
%\begin{figure}
%\centering
%\includegraphics[width=0.4\columnwidth, angle=0]{./figs/Machine_Description.pdf}
%\caption{Machine Description of Lenovo Y400.}
%\end{figure}
%\end{comment}

\begin{figure}[!htp]
\centering
\includegraphics[width=0.5\textwidth]{Machine_Description.pdf}
 \caption{Machine Description of Lenovo Y400.}
\end{figure}


\section{CPU, Scheduling, and OS Services }
\label{sec:cpu}
In this section we design several experiments to measure the performance of operations related to on-chip processor scheduling. Our experiments will provide a couple of measured results of interests.
\begin{itemize}
\item How much overhead a single experimental measurement costs.
\item How much overhead a library procedure call costs.
\item How much overhead a system procedure call costs.
\item How much overhead creating a new process (kernel thread) costs.
\item How much overhead a context switch costs.
\end{itemize}

\end{document}

